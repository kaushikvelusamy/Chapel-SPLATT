Look for places with direct array assignment and see if we can replace with ref,
as a direct assignment makes a copy of the array

Change all loops to use domains, if possible. This is supposed to speed-up the runtime bounds checking

Change memcpy calls, if possible, to use direct array assignment.

Look for places to use slicing instead of loops when doing assignment

Replace direct C-interfacing with more Chapel-like statements

Do entire-array operations work in parallel automatically? As in, does sqrt(A) perform the sqrt() function
on each element of A in parallel?

It'd be nice to have some more fine-grain control over BLAS/LAPACK functions.

Is there a Chapel equivalent to a omp for within an omp parallel section? What happens with
a forall within a coforall?

Having a built in lock would be great, but not entirely necessary; using sync vars isn't too bad.

Do the linea algebra routines on matrices/vectors execute in parallel?

Be careful when directly porting OMP code that is of the form:

omp parallel
{
    stuff
    omp for
    for i...
        stuff
    more stuff
}

There is an implicit barrier after the omp for. We need to do the barrier explicitly in
Chapel

Not being able to store ref in classes is a draw back

It seems difficult to create a reference to an array of records/objects. This is easy in
C because we just say something like:
    myType *ref = myRecords;    //myRecords is an array of myType objects
Then whatever we do to myRecord affects ref and vice versa. But in Chapel, the above statement
would be an array assignment, which creates a copy of myRecords. 
